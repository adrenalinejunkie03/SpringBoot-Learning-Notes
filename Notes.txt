
NOTES WRITTEN BY MUHAMMAD SUHAIB
LINKEDIN : linkedin.com/in/msuhaib-03/fsjavadev/
mail: muhammadsuhaib2805@gmail.com



------------------------------------ LECTURE 1 -------------------------------------
Spring Boots is framework for bulding application in Java --> it basically provides tools
Easy to create stand-alone, production-grade Spring Based Applications 

Spring framework reduce boilerplate code, reduce effort to setup and config Spring Application.
Auto-config & StandAlone App, No need for Tomcat server, No need to config any server or its config !!

Annotation is a hint and @SpringBootApplication replaces need for setting Spring Application manually.
It comes with a lot of automatic configuration
Spring	Application.run() to start the application

Bean can be reused. --> Bean is an object
ApplicationContext is asked to provide bean. ---> It creates and provides you bean

------------------------------------ LECTURE 2 -------------------------------------

Download & Installation of IntelliJ
Adoptium Eclipse

------------------------------------ LECTURE 3 -------------------------------------

Java8 & Java11 are the most stable
We will do version upgrade as well later on which is work of developer.

------------------------------------ LECTURE 4 -------------------------------------

Spring Boot Project ( Journal App )
jar is run just like that where as war has to be deployed on external server
Spring Initializer
Maven helps to convert to jar or war
Add Dependencies --> Spring Web for APIs & uses Apache Tomcat Server
Added RestController to for  @GetMapping for context on localhost:8080


------------------------------------ LECTURE 5 -------------------------------------

Download & Install maven

------------------------------------ LECTURE 6 -------------------------------------

Maven creates build --> build simplify, automate, dependency manage
All jars are available and downloaded & used

Maven repository has all the dependencies you need for your project, it will download the jar in external libraries ---> Dependency

validate, compile, test, package, verify, install, deploy ---> Build lifecycle of Maven

Make sure to be in the same folder as project where all the files and folders are lying
mvn validate, mvn compile, mvn test, mvn package( no need to write all the commands again and again, just package is enough for all work) will make jar,
mvn install ( this creates a path where the jar will be stored and can be used again in future ), mvn clean ( removes all that was present or created using mvn )

java -jar <file name of jar in target folder>  --> runs project

pom means build tool is maven

------------------------------------ LECTURE 7 -------------------------------------

.idea --> intellij related config
.mvn --> maven wrapper
src -> main ( functionality )
src -> test ( testing )
pom.xml --> all info related to project, external libraries

plugin, build --> packaging code to jar or war 

parent fetch required dependencies 

.jar.original only has compiled code
.jar has the plugins, dependencies, compiled code, self-contained server ( self-contained jar) --> fat jar

mvn package also does the repackaging, repackages the original jar and jar

------------------------------------ LECTURE 8 -------------------------------------

We used to manually create object i.e: car c = new car();
Externalize the object creation --> Inversion of Control  ( Spring provides IOC Container ) 
All the classes in project are stored in IOC Container, no need to create object, it wil be done by IOC.

Control is inverted, all the objects are present in a box called IOC.
ApplicationContext is a way to apply IOC. 

IOC scans the classes but adds only those which contain:
@Component, --> if this annotation is present at any class, IOC will accept and save this class in it.
Class,interface,method,field. ( @ tells some info about those )

@Component makes Beans
Bean -> object
The object in IOC container is called Bean.

@SpringBootApplication -> it runs the entire project, it is entry point and main method ( it is only 1 and it is only going to be on main class )
All the classes, beans must be made in base class / package, oonly then it could be scanned by SpringBootApplication
It contains 3 Annotations:
@Configuration --> Bean creation of that class
@EnableAutoConfiguration --> There's no need to setup things manually, spring boot does it all by itself i.e mongo db setup, server setup
@ComponentScan --> IOC Container / Scanning / Scan Beans

@Autowired, --> dependency injection
if a class needs to be used in another class, the one we want to use, write the @Autowired annotation on it, so its called dependency injection.
There's no need to make object, it gives direct access to that class's objects, methods, interface.
By using it, any calss in future can use this single instance

@Bean, --> this can be used to crate bean in a class but it is only used on a function


------------------------------------ LECTURE 9 -------------------------------------

New SpringBoot Project creation.

Spring Initializer:
Lang -> Java
Project -> Maven
SpringBoot -> ( select older version )
Group: Name of company in reverse fashion
Artifact: Name of project ( must begin with lowercase )
Name: ( Any name -- must be human-readable )
Description: ( Any description )
Packaging: Jar
Java : ( Select older version, either one installed in your pc or a little above your version )
Dependencies: Spring Web

Representative State Transfer & Application Programming Interface
REST API --> How to access something on server , therefore ( GET + 172.17.18.19:8080/netflix/plans ) 
URL+Endpoint( 122.76.0.45:8080 + /plans/pricing )

URL + HTTP Verb
GET, PUT, POST, DELETE ( See, Modify, Create, Remove )

@RestController at class will be a Bean --> it is used as a component but providing some additional functionality as well
End-points are written as method

Postman is used to check API
@RequestMapping adds mapping to entire class and then finds the sub mappings in that class
Methods inside a controller class should be public so that they can be accessible and invoked by the spring framework or external http requests.
Selecting "raw" and "JSON" in body of POST request in Postman indicates that request body will contain data in JSON format, allowing the server to parse and process
the incoming data accurately.

@RequestBody in a parameter of function is like: hey spring, take the data from the request and turn it into java object that I can use in my code
@PathVariable --> have to give the path to the endpoint for api hit

? --> this is request parameter
/ --> this is path variable

:)

------------------------------------ LECTURE 10 -------------------------------------

MongoDB installation on Windows.

------------------------------------ LECTURE 11 -------------------------------------

MongoDB is database and it has collection not table.
Collection has fields(columns) and rows(documents).

Run cmd as an administrator and type mongosh.
show dbs
use <name of db to create>
show collections  --> no tables created yet.
db.createCollection <name of table>
db.students.insertOne({"name":"Sobi", "age":22})
db.students.insertOne({"name":"Rabiya", "age":27})

What it is actually doing is that it goes to current selected database,create a table if not like here <students> and then write the rows as JSON.

db.students.find() ---> show the data in the table
db.students.find().pretty() ---> show in a proper manner of documents(rows)
db.students.find({name:"Rabiya"}) --> It finds exact field through JSON
db.students.deleteOne({name:"Suhaib"})


------------------------------------ LECTURE 12 -------------------------------------

ORM --> ( Object Relational Model ) : technique used to map java objects to database tables
Allows devs to work with database using OOP, making it easier to interact with relational database.

Consider a Java class called Users and db called users. ORM maps the fields in User class to columns in the users table, making easier to insert,upd,del,retrieve.

JPA ---> Java Persistence API 
Provide set rules to achieve ORM
It acts as a bridge between OOP & relational database.

Persistence Provider / ORM Tools ---> To use JPA, you need persistence provider.
JPA persistence providers include Hibernate, EclipseLink and OpenJPA.  ( You will use JPA but by which means you want to use JPA )
We use these to interact with our databases

Spring Data JPA --> It simplifies working with JPA. You will still need a JPA provider.

MongoDB is a NoSQL database that uses a different data model, typically based on collections of documents, which are schema-less or have flexible schemas.
JPA is not used with MongoDB.
As it is a NoSQL database so SpringData JPA serves as the persistence provider for MongoDB.

QueryMethodDSL & CriteriaAPI are 2 diff ways to interact with database:
SpringDataJPA for Relational database.
SpringData MongoDB for MongoDB Database.

QueryMethodDSL: create queries based on method naming conventions
CriteriaAPI : dynamic & programmatic approach for complex and custom queries


------------------------------------ LECTURE 13 -------------------------------------

Add springdb mongodb dependency in pom.xml

Goto application.properties in resources folder and provide this info:
spring.data.mongodb.host=localhost
spring.data.mongodb.port=27017

This local host and port can vary if you work at office or somewhere.

Now create a package called service and class within it which will hold all the business logic here.
We will also create a an interface of repository within a repository package

Controller calls the service, service calls repo.
controller ---> service --> repo(interface)

Repo runs query from database. The database that you wanna play with, extends that in repo interface.
extends MongoRepository
MongoRepository is an interface provided by default SpringDataMongoDB contains the code for table(collection) when ctrl+right-click.
It will contain 2 parameters.

@Document to be written on our pojo class to make it equals to row for db. ( The pojo class will be equal to 1 row containing all fields in it)
@Id makes an initialization unique/primary key.

In the v2 controller, we @AutoWired the JourmalEntryService so no need to rewrite it for object.

Now run the program and hit the postman with a text body with json to check if POST verb is working.
Then Open the mongosh and hit show dbs, then use journaldb, show collections --> ( journalEntry is shown )
db.journalEntry.find() ---> just show the data we hit from POST in Postman
If you don't have or enter id, mongoDB itself generates a variable of ObjectID with a unique id for each document.
You may delete the entries from table now in mongosh and goto JournalEntry class and convert the String Id to ObjectId.
Add LocalDateTime as well.
Optional is data type where there could be data and there could not be.

Create all the services in journalEntryService --> All what you need, Save, Update, List, Create
JournalEntry has all the ---> Variables declared with getters and setters.
JournalEntryRepo extends MongoRepository and nothing else in code.
JournalEntryController is where you hit the APIs and use @RestController with all the HTTP Verbs for the services you need.

In the JournalEntry, where you wrote @Document(collection="journal_entries")
you have to use the same document is mongosh for accessing it.
Like: db.journal_entries.find()

ALHAMDULILAH!!!! Troubleshooted the problem in IntelliJ & Mongosh by self after analyzing the errors generated and help from GPT.
APIs are being hit now .. :)

------------------------------------ LECTURE 14 -------------------------------------
Request & Response
Response Entity + HTTP Code
3 digit numeric code returned by a server. These are used to convey information about the result or status of requested operation.
HTTP Codes
1xx --> Information ( request was received and understood & processed, rarely seen in practice )
2xx --> Successful ( request was successfully received, understood & processed by the server ) -> 200,201,204
3xx --> Redirection ( further action needed to complete the request. Used when client needs to take additional action to access the requested resource ) -> 301(Resource
has been permanently moved to a different URL), 302( Resource Temporarily moved to a different URL, Redirect field alsi given), 304(Cached version can be used)
4xx --> Error on client's part, authentication issues, 400(Bad Request), 401(Unauthorized), 403(Forbidden)
5xx --> Server Error ,500(Internal Server Error), 502(Bad Gateway). 503(Service Unavailable/temp overloading or maintenance)

Response Entity class is a part of Spring Framework and is commonly used in SpringBoot apps to customize HTTP response.
Provides methods for setting reponse status,header & body.
Make changes in the JournalEntryController and add the ResponseEntity with status codes. 



------------------------------------ LECTURE 15 -------------------------------------

Lombok is popular library in Java ecosystem, often used in SpringBoot apps. It aims to reduce boilerplate. Lombok achieves this by generating this code automatically
during compilation based on annotations you add to your Java class.

Goto Project Lombok, select install ( maven ) and add the dependency to pom.xml

In your entity vlass where you need to do the work reduction, add the annotations there like:
@Getter, @Setter, @Builder, &EqualsandHashCode, @ToString
Also install plugin of Lombok in intelliJ
But @Data annotation of Lombok is equals to all the above written annotations,it includes all of them.
Lombok generates bytecode for methods as speicifed by the annotations used in your code. This generated code is added to the compiled class files (.class).

Java cmopiler compiles your classes, including the generated code. This means that the generated methods become part of your compiled class files.
When you run your app the generated methods are available for use, just like any other method in your class.



------------------------------------ LECTURE 16 -------------------------------------

Creating a connection between JournalEntry & User
@DBRef to make a link of a database into another one, and it works as a foreign key. JournalEntries in our project is making a reference, link making between 2 collections.
Parent-child relationship is established here in User.java class
spring.data.mongodb.auto-index-creation=true  --> This has to be added to application.properties for username indexing
Make a UserController,UserRepo,UserService same as the journal classes but do work as following the service class
In UserRepo make a method of username.

Now to create a connection betwwen the User & Journal, we will start wokring on the JournalControllerV2. 
Do the Autowire UserService class in JournalEntryController and use @PathVariable to find userName.
All the journalEntriesof that particular user will appear.

UserName + journalEntry --> API 
userName comes from user and user has id,username,password and journal entries.
journalEntry has journalEntries.
Id is saved in journalEntries of journalEntry.
So this API makes enter journalEntry into journalEntries & it also saves the user's journalEntries's id from users.

Everything good till now!!! Get,Post,Put,Delete working and their connection of users and journal_entries are also working as expected.
Working on cascade mongodb as deleting an entry from journal_entries doesn't delete from the user, it is stil there automatically, therefore has to be done manually now.

Done the work  on JournalEntryService for deletion.
Create JournalEntry on postman:
localhost:8080/journal/<userName>   --> POST method
db.journal_entries.find()  --> entry created
db.users.find() --> entry also created here

Deletion on postman:
localhost:8080/journal/id/<userName>/<objectid from journal_entries>
db.journal_entries.find() --> entry is deleted
db.users.find() --> entry deleted from here too

Consistency will  come on users' next save but we want it currently delete, delete instantly. 

Now all the HTTP verbs are working and connection/relation made between users and journal_entries collection.

Problem here is that the transaction between the users and journal_entries has to be same all the time and at the same times. If any error occurs in saving journalEntry,
it is going in JournalEntry and Users collection as well, it should occur as one operation.

------------------------------------ LECTURE 17 -------------------------------------

@Transactional -->  will be used in case of transaction where if one succeeds, means all will succeed, but if one is wrong or discarded then all will be discarded.

@EnableTransactionManagement --> it is added on main SpringBootApplication.
What happens here is that it creates a container, which contains all the methods that have @Transactional annotaion used on it and it provides the area for springboot
application to search and make the application and transaction atomic( if one fails, all will fail, if one passes, all will pass )
Isolation is also achieved by using it. 

All of it is basically done by an Interface PlatformTransactionManager which is responsible for transactions, commit & rollback.
MongoTransactionManager is class which implements it. --> it is all wokring behind.
A @Bean of platformtransactionmanager is created in main app which has mongodatabasefactory as param & return instance of mongotransactionmanager.
MongoDatabaseFactory( an interace ) helps is building connection with the database --> used as parameter in method of PlatformTransactionManager.
And it is an implementation of SimpleMongoClientDatabaseFactory.

You can also create a package with class TransactionConfig for the above mentioned things rather than creating them in main SpringBootApplication but we will keep it.


------------------------------------ LECTURE 18 -------------------------------------

Create an account on MongoDB Atlas.
Do the personalization, and select the free plan.
Select AWS as Provider & Region as you like and then create Deployment after giving it a name.
(password), (username)

mongodb+srv://muhammadsuhaib2805:<db_password>@cluster0.9wu5ofl.mongodb.net/?retryWrites=true&w=majority&appName=Cluster0 ---> ( paste in springboot project )
This is obtained from the connect button & then drivers option.

Don't forget to hit add my current ip address to make it whitelist for use in Quickstart Security option.
Finish & Close.

Cluster is a formation from nodes means servers. Data is evenly distributed so if a server goes down, data can be fetched through another( It is called sharding ). 

Paste the uri in springbootapp in application.properties with:
spring.data.mongodb.uri=mongodb+srv://sobi7:<db_password>@cluster0.ar8adhd.mongodb.net/?retryWrites=true&w=majority&appName=Cluster0
This is hard-coded and not a good practice tho for now but we will externalize it later.

___________________________ SERIOUS PROBLEM OCCURED HERE!!!!! JAVA VERSION 8 IS NOT COMPATIBLE WITH CURRENT SPRINGBOOT VERSION THEREFORE IT IS NOT GOING TO RUN
ANYTHING ON MONGODB ATLAS. IT TOOK A LOT OF HOURS AND TROUBLESHOOTING TO KNOW WHAT WENT WRONG. DOWNLOAD JAVA 17 NOW, SET JDK, SDK___________________________


DAYSS AND DAYSSS PASSED!!!!! FINALLY TROUBLESHOOTED THE PROBLEM, IT WAS THE PROXY THAT WAS STOPPING US TO CONNECT, EVERYTHING WAS FINE, THE CONNECTION STRING, THE
SPRING BOOT PROJECT :)
TOOK APPROX 3 DAYS TO KNOW WHY IS IT HAPPENING AND DID ALL ON MY OWN, NO HELP FROM TUTORIALS OR GPT...


Connection String would look something like this:
mongodb+srv://sobi7:<db_password>@cluster0.ar8adhd.mongodb.net/?retryWrites=true&w=majority&appName=Cluster0

I recommend doing all the stuff on Studio3t and it can be connected to MongoDB Atlas

------------------------------------ LECTURE 19 -------------------------------------

SpringSecurity class download. Only applies to latest users of springboot with ver 3.x and above.


------------------------------------ LECTURE 20 -------------------------------------

Spring Security is a powerful framework that is used to handle authentication & authorization. ( who to allow and whom to not, right credentials ) & ( if access, what can you do, admin/read/write access )

A dependency is added in pom.xml to secure all the end-points, it uses HTTP Basic Authentication. (encoded-string)
The client sends an authorization header --> Authorization: Basic encoded String, The server decodes thr string, extracts username & password and verifies them.
Access is granted, if they are correct.
username:password  --> it is encoded in base64
Spring Security will generate a default user with a random password that is printed in console logs.

Run you Spring app & a passowrd will be generated
Goto postman, hit any GET journalentry and then hit send, it will say 401 Unauthorized, goto auth -> basic auth, type username and the password from springboot and hit send.
( Remember that this username & password is different from the users we created )
Now it will show authorized and an OK Status with your entry in response.

Now we need Customize Authentication because it was only done for a single user.
@EnableWeb@Security --> Web Security support is enabled. It's used in conjunction with @Configuration
WebSecurityConfigureAdapter is a utility class that provides default configurations & allows customization of certain features. By extending it, you can configure &
customize your spring secity for your application needs.

http.authorizeRequests --> starts authorizing the requests
.anyMatchers("/hello").permitAll --> HTTP request matching the part hello should be allowed for all users whether auth or not
.anyRequest().authenticated() --> Specifies any request, not matched by previous matchers should be authenticated, meaning users have to provide valid credentialsto access the endpoints.
.and() --> method to join several configurations.
.formLogin() --> Enables form-based authentication. It will provide a form for the user to enter their username and password. If user is not authenticated and try to access a secure endpoint, they'll be 
redirected to the default login form.
Spring security provides an in-built controller that handles /login path. It is responsible for rendering the default login form when a GET request is made to /login.
Spring also provides logout functionality. .logout(), post request to /logout will log the user out & invalidate their session.

Basic Authentication is by its design stateless. ( 2nd request doesn't know, what was 1st request ) , All 100 requests are made individually.

Spring Security:
Session Creation
Session Cookie
Security Context
Session Timeout
Logout
Remember Me

We want our SpringBoot application to authenticate users based on their credentials stored in a MongoDB database.
Users and passwords(hashed) will be stored in mongodb & when users try to authenticate, system checks for provided creds and match against what's in the db.

Now we have to create a UserDetailsServiceImpl which is other than our business logic and it is an implementation of an interface with methods already defined.

Make changes, as the Public Controller now has the ability to add user, and UserController deletes and updates user.
All authentication done, some testing through postmn required!!



------------------------------------ LECTURE 21 -------------------------------------


We will be working on Journal Entry Controller and will add authentication to it and then there's no need for @PathVariable as we are sending userName and password
through auth and can be checked in Postman.
Goto Postman and localhost:8080/journal and select Auth and then BasicAuth, provide the username and password.
It was done for GetMapping, now do same for PostMapping, add those 2 lines of authentication and remove any pathvariable.

Postman was giving unauthorized error, it can be solved by right providing the username and password in auth and make sure its encrypted and not plain text format
and also for this project there's no need to use @Transactional, it took couple of hours for me to know where the actual problem lies.
Either remove it or use the Mongodb Factory for it.
Now its working very fine!!!! :)
Check the mongodb atlas collections and there will be users and journal_entries under the journaldb collection with the entity having same id.

CreateUser, then Add journal entry and then get by id.... Make sure to use the basic auth & provide the raw username and password.
Delete the journal entry as well by providing the id from Mongodb Atlas and it should be removed overall.

ALL HTTP VERBS ARE WORKING AND ALL DONE WORK ON GET,PUT,POST,DELETE & BY THEIR RESPECTIVE IDS.
Checked on MongoDB Atlas as well. Authorization done by raw format and object id taken from mongodb for id.


------------------------------------ LECTURE 22 -------------------------------------

Role Based Authorization is done here. A new API and controller is created for admin so only admin can see all users and entries while common users can't have access
and wouldn't be able to see the changes and all users and can't use someone's auth.

We will create an a new admin controller which will fetch all the details, but before that we have to make a change(already done) in spring security by adding role of
admin as has Role for a specific role.
So to allow a specific person to be able to see or make changes, goto mongodb atlas and the user you want to make an admin and edit its user entry and type ADMIN in it.
By updating and editing the role of a specific user, enter its basic auth in Postman and boom!! You can see all the entries and at the same time if you try to enter
anyone else's basic auth, it will say 401 Unauthorized.

We have to create first user and admin manually so we can create or change after and even make a method to create new admin in the controller and UserService as well
by giving it role of a USER as well as an ADMIN as given in the SpringSecurity class. 
So basically this manually created admin can further create an admin and that admin will also be able to see users and entries by enabling its username and password
as auth just like the first admin.

Basically by creating a new user first and then, first manual admin, you will create a new admin from its basic auth, then the created admin will use its raw username
and password in get all to see all
the entries and users

------------------------------------ LECTURE 23 -------------------------------------

In this lecture we will see if there's any other way to write or handle application.properties as we had been writing our setting in it, so we can try to pass
command line arguments in spring boot application.     ----> Basically a YAML lecture... !

Classpath has jars, class and configuration files.
SpringBoot finds itself the class path, src --> main --> resources --> application.properties
Dependenceis are also packaged in classpath.

So another way to write configs is YAML.
It doesn't need to have tags rather it is human readable and has indentation.
YAML aint't markup language !! :)
.yml is extension.

Copy paste that same app.properties but use .yml. Now use this sort of indentation and we don't need to over write things and again and again.

spring:
  data:
    mongodb:
      uri: mongodb+srv://sobi7:test1234@cluster0.ar8adhd.mongodb.net/?retryWrites=true&w=majority&appName=Cluster0
      database: journaldb
      auto-index-creation: true

You have to write a new property from starting and just use : and hit enter to move to next line. Intellij is smart and can recognize.
You can keep poth .properties and .yml but priority is application.properties.

You can provide context path and port of your choice as well but remember that context path then has to be added before every api here in this case of project, /journal
and port can be changed from 8080 to 8081 and would work fine.
application.properties can be deleted now and project would work.

Now almost same can be done in terminal, just write mvn package and then in test you can see jar and can run it by java -jar <name of jar> --property=value
So you can use properties in terminal as well.
So priority is:
application.properties
command line terminal
application.yml


------------------------------------ LECTURE 24 -------------------------------------

JUnit TESTING IN THIS LECTURE!!
API has to be tested. Unit & Component Testing.
Java Unit is a framework for testing -->Java Unit
All tests have to be written in tests, maven ignores test folder so it is not included in jar.

You can write tests as methods and class name can be same as the ones from main.
Make a package called service for example in test and add class UserServiceTests.

@Test ---> This annotation is used on methods that we need to test
assertEquals()  --> this contains parameters for expected and actual value, you can run and check if this is true. This will be imported as static import.

assert ---> there are couple of option after you write assert and you can choose what to test in what context.
You can also add a message after providing parameters in test by comma separated so it tells, which test actually failed.

Now we try to test findByUsername from UserService and we @Autowire userRepo, make a method and use assertNotNull just to know that answer should not be null.
Something like this: userRepo.findByUserName("username here that has been created.");

Make sure to add
@SpringBootTest --> this runs tests like actual project as there is no springboot app context in tests therefore without it, it will fail to run.

@ParametrizedTest --> This annotation is used when you want to carry multiple tests on a single method with changing values and don't want to write method again & again.
Values are fetched here and how they are fetched? They are fetched through another annotation where you can give files:
@CsvSource({
})
Each line in csv represents one test for the parameters.
"1,2,2",
"2,10,12,
"3,3,9"

@ParameterizedTest
    @CsvSource({
            "1,1,2",
            "3,3,9",
            "4,5,13"
    })
    public void test(int a, int b, int expected){
        assertEquals(expected, a+b);
    }

Now if we run a class and want to disable a test we have annotation for that too:
@Disabled --> it disables the method that you don't want to test.

@EnumSource --> another same as CsvSource
@ValueSource ---> this annotation is almost same as CsvSource but as we are not giving any file, we can add ints, or strings to it follwed by = sign and then whatever
you like to test.
@ValueSource(strings = {
"Taha",
"Disha",
"Sobi"
})

@ArgumentSource --> This is long and a little difficult to understand and part of JUnit testing & not exactly part of a SpringBoot therefore can be ignored & above
provided tests can be implemented and are very effective.
But it is basically used for custom arguments by making a new class of that implements ArgumentsProvider & a method @Override of Stream that extends ?Arguments
and builder for testing the entity variables.

Code coverage / tests ---> This is used to show or tell that how much of your project or lines of code have been tested so a plugin is installed called
Code Coverage for Java. ( Not exactly available in this IntelliJ version )
BTW it shows coverage in % when run on tests. It creates a report.
You can export report as well.

@BeforeEach ---> It will run before each test present. If we have to initialze something before each test, then this annotation has to be used.
@BeforeAll ---> This method test will run before all & any.
@AfterAll ---> This if used on a method will run after all the tests.


------------------------------------ LECTURE 25 -------------------------------------

@MockBean ---> this annotation is used to mock, actual service / dependency is mocked.
Now eveytime entire application takes time, all things are injected and autowired, connection to database is made so it takes a lot of time, so to make things faster,
we have to use mockito.
Dummy things are made so a mock db can be made and the actual connection to real db is not made and no time is wasted.
Before findind any specific username, we use the --> when, thenReturn

@InjectMocks ---> Injects the mocked dependency
We are doing all this because @Autowired was used, @SpringBootTest was used so they were loading the entire spring application for test purpose but here we want to mock
things and not use the actual ones, therfore we have to remove @SpringBootTest and @Autowired so @Mock ( @MockBean is used with spring context only ) & @InjectMocks are
2 annotations used for only working with mocks and not loading the spring boot application context whiich takes time to load. By doing so, we are preventing our tests
classes and methods from being components.

The application would still fail so we have to write a method of @BeforeEach, in which we initialize Mocks and inject them too.
Now the initialization is done and our mock/fake test will run smooth and no actual connection will be made.



------------------------------------ LECTURE 26 -------------------------------------

Profiles --> Dev & Prod Environment
Dev env is usually testing, fake users whereas prod env is real with real users.

Difference comes in configurations when in Production Environment, SpringBoot gives us flexibilty of changing configurations based on Environment.
By default we have application.config / application.yml, but we are creating 2 more here : application-dev.yml & application-prod.yml

This is how you will write you application.yml first:
spring:
  profiles:
    active: dev ( write name of profile you want to run, either dev or prod )

You are basically running the application-dev.yml ---> which was actually copy pasted from application.yml and it was replaced with above code and it runs fine!!

If there are exact same config in both of the profiles, you can write them in application.yml, rest of the changes are done in separate profiles.
Rather than rewriting and changes dev / prod again and again, you can goto environment variables in IntelliJ and write spring.profiles.active=dev

Now in production, you aren't going to use IntelliJ, you will run jar.

You can do all the above things in the command line using maven and jar.
.\mvnw clean package -D spring.profiles.active=dev   ---> jvm system properties
&
then moving to our target folder where jar is created, in command line:
java -jar <name of jar > --spring.profiles.active=dev  ---> variables pass

Jenkins do all the things automatically, no need to do all these things and it does everything by just a single click.
We can whitelist the server that load everything from them so we set active profile of prod or dev as you like because server cannot be accessed by local machine, things
work entirely different on server, therefore set profile either on environment variables or use Jenkins.

Bean made based on profile.
@Profile("dev")
You can add annotation to a class so that it tells project if it belongs to dev or prod
 
You can do the same for tests classes as well by adding an annotation:
@ActiveProfiles("prod")

You can get the environment context as well by initializing variables of spring application and using it with getEnvironment(), so on starting the project it shows 
which profile is active or not.


------------------------------------ LECTURE 27 -------------------------------------

This lecture is regarding Logging.

Logging is an essential aspect of application development that allows developerss to monitor & trouleshoot their applications.
Unexpected behavior on production of API if crashed, we can check by LOGGING, either logs are printing or not.

Logback, Log4j2 & Java Util Logging(JUL) ---> 3 frameworks are available in springboot.
Logback: logging framework that offers flexible config & good performance & a default in spring boot apps.
Log4j2: Async logging & support for various output formats.
JUL: default logging standard in java standard edition. --> it's part of JDK.

Usually we use logback. Simplicity & flexibilty in spring boot.

To customize logging, you can create logback.xml file in src/main/resources.

Logging levels: Help in categorizing log statements based on their severity.
Trace, Debug, Info, Warn, Error

Annotations used:
@Slf4j ---> this will be used in springboot app & our project
@Log4j2

First initialize the logger instance in a class where you want to implement Log. We are doing in JournalEntryService. Like this:
private static final Logger logger = LoggerFactory.getLogger(JournalEntryService.class);
<use class where it is implemented>
logger.error("Error occured for {} :",user.getUserName(),e); ---> this is how it is implemented when we have to initalize entire line above, but we can simply use
annotation as well.
@slf4j ---> when this annotation is used, there's no need to initialize that entire line of private static final. Just in catch bloack, use (log.), and it will work.

simple logging facade for java.
slf4j is logging abstraction framework. 

Customization has to be done to make Trace and Debug run, the rest can run like that.

This is how customization is done in application.xml for DEBUG and TRACE.    
logging:
  level:
    net:
      engineeringdigest:
        journalApp: DEBUG

But it is better to use .xml and not .yml because xml is basic for logging therefore that's what we are going to do.
Appender means where do you want to print your logs. Console & File appender.
Create a new file in resources called logback.xml and write the contents like this:
<configuration>

    <appender name = "myConsoleAppender" class="ch.qos.logback.core.ConsoleAppender">
        <encoder>
            <pattern>
                %d{HH:mm:ss.SS} [%thread] %-5level %logger{36} - %msg%n
            </pattern>
        </encoder>
    </appender>

    <appender name = "myFileAppender" class="ch.qos.logback.core.FileAppender">
        <encoder>
            <pattern>
                %d{HH:mm:ss.SS} [%thread] %-5level %logger{36} - %msg%n
            </pattern>
        </encoder>
        <file>
            journalApp.log
        </file>
    </appender>

    <root level="INFO">
        <appender-ref ref="myConsoleAppender" />
        <appender-ref ref="myFileAppender" />
    </root>

</configuration>

So info in this is customizable and modifiable, therefore no need to remember and learn it entirely.
It's creating logs in File as well as on console as well.
We have to give path to <file> outside of project. So that logs are pasted there in root directory in Windows and Linux.
There's RollingFileAppender class and it has RollingPolicy which further contains fileNamePattern, maxFileSize & maxHistory.
As it is seen that this .xml for logging is heavily customizable.



------------------------------------ LECTURE 28 -------------------------------------

Code Quality Check ---> SonarCube
It can be installed either locally on a system or on its own SonarCloud.
Code also has to be present on GitHub.



